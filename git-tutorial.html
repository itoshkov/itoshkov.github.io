<h1>Overview</h1>

<blockquote>
  <p>A conceptual model is an explanation, usually highly simplified, of how
something works. It doesnâ€™t have to be complete or even accurate as long as it
is useful.</p>

<p>Don Norman - The Design of Everyday Things</p>
</blockquote>

<p>In this tutorial I'll try to describe how git works, without using git. Instead,
we'll create a simple, git-like system using just zip files <code>diff</code> and <code>patch</code>.</p>

<p>The idea is to build a good model of how git works <em>conceptually</em>.</p>

<p>If can <a href="https://youtu.be/dQw4w9WgXcQ">go here</a> if you prefer to watch this
tutorial, instead of reading it.</p>

<p>I'll be using some simple Linux commands like <code>mkdir</code>, <code>cd</code>, <code>ls</code> and <code>cp</code>.</p>

<h1>Version Control Without Git</h1>

<h2>The Humble Beginning</h2>

<p>Let's start by creating our new project:</p>

<p><code>bash
mkdir ProjectX
cd ProjectX
</code></p>

<p>And let's put our top-secret program in <code>main.c</code>:</p>

<p>```c</p>

<h1>include <stdio.h></h1>

<p>void main() {
    printf("ALL YOUR BASE ARE BELONG TO US.");
}
```</p>

<p>This is our starting point. This is our first version and we want to save it and
be able to come back to it. One way we can do that is to copy the whole
<code>ProjectX</code> directory, like this:</p>

<p><code>bash
cd ..
cp --recusive ProjectX ProjectX-v0
cd ProjectX
</code></p>

<p>Nice! (Well, sort of.)</p>

<p>When we run our program we see that we forgot to print new line at the end.
Let's fix this.</p>

<p>```c</p>

<h1>include <stdio.h></h1>

<p>void main() {
    printf("ALL YOUR BASE ARE BELONG TO US.\n");
}
```</p>

<p>We can see the differences between this version and v0 like this:</p>

<p><code>bash
diff --recusive --unified ../ProjectX-v0 .
</code></p>

<p>The <code>--recusive</code> option tells <code>diff</code> go compare the directories recursively, and
the <code>--unified</code> -- to show the differences in the so-called unified format.</p>

<p>```diff
--- ../ProjectX-v0/main.c   2021-09-06 13:58:33.718024787 +0300
+++ ./main.c    2021-09-06 13:58:46.690096675 +0300
@@ -1,5 +1,5 @@
 #include <stdio.h></p>

<p>void main() {
-   printf("ALL YOUR BASE ARE BELONG TO US.");
+   printf("ALL YOUR BASE ARE BELONG TO US.\n");
 }
```</p>

<p>As you can see, the file <code>main.c</code> has one line removed and one line added.</p>

<p>OK, it's time to save this new version of our software:</p>

<p><code>bash
cd ..
cp --recusive ProjectX ProjectX-v1
cd ProjectX
</code></p>

<h2>Archives</h2>

<p>One of the problems with copying folders like that is, that they tend to take a
lot of space. Also, it's easy to accidentally change things in the "archive"
folder, instead of in the working one.</p>

<p>We can fix these by using Zip files instead of folders. Zip files still can be
changed, but at least it's harder to do so by mistake.</p>

<p>Let's also start calling these archives commits. For now a commit is just a
snapshot of the current sources, stored in a zip file.</p>

<p>We can now create our zip files:</p>

<p><code>bash
cd ..
cd ProjectX-v0
zip -r ../ProjectX-v0.zip .
cd ..
cd ProjectX-v1
zip -r ../ProjectX-v1.zip .
cd ..
rm -rf ProjectX-v0 ProjectX-v1 # remove the old directories
</code></p>

<p>One thing we can't do directly anymore is to compare versions. But we can just
unzip the version(s) that we need in some temporary folders and then compare.
It's a bit of a hassle, but we can automate it with a small script if we want
to.</p>

<p>Another thing I don't like is, that the version archives are just lying around
and littering the parent directory. Let's move them in a new folder inside the
project:</p>

<p><code>bash
cd ProjectX
mkdir -p .repo/commits
mv ../ProjectX-v0.zip repo/commits/c0.zip
mv ../ProjectX-v1.zip repo/commits/c1.zip
</code></p>

<p>In Linux, UNIX and macOS files and folders starting with dot <code>.</code> are "hidden".
If you type <code>ls</code> you won't see them, but if you type <code>ls -a</code> you will. Besides
that, they are just normal files and folders.</p>

<p>We created a <code>commits</code> folder inside, because we'll proably want to put other
things in the <code>.repo</code> in the future.</p>

<p>To see how our current system works, let's modify the <code>main.c</code> file again and
make a new version:</p>

<p>```c</p>

<h1>include <stdio.h></h1>

<p>void main() {
    printf("CATS: ALL YOUR BASE ARE BELONG TO US.\n");
}
```</p>

<p><code>bash
zip -r .repo/commits/c2.zip .
</code></p>

<p><code>
  adding: main.c (stored 0%)
  adding: .repo/ (stored 0%)
  adding: .repo/commits/ (stored 0%)
  adding: .repo/commits/c1.zip (stored 0%)
  adding: .repo/commits/c0.zip (stored 0%)
  adding: main (deflated 85%)
  adding: main.o (deflated 67%)
</code></p>

<p>Oops! We added the previous commits in the zip file too. We also notice that we
are storing the <code>main.o</code> and <code>main</code> files. These are not needed as they are
generated by the compiler.</p>

<p>To fix this, let's create a list of files to ignore. Put the following in a
<code>.ignore</code> file:</p>

<p><code>
.repo/commits/*
*.o
main
</code></p>

<p><code>bash
rm .repo/commits/c2.zip
zip -r -x@.ignore .repo/c2.zip .
</code></p>

<p>The <code>-x@.ignore</code> option tells <code>zip</code> to exclude the files mentioned in the
<code>.ignore</code> file. Notice that <code>.ignore</code> is included in the archive. That's good.
We want to track its content with new versions.</p>

<h2>Branches</h2>

<p>So far our versions are named sequentially <code>c0</code>, <code>c1</code>, <code>c2</code> and so on. Also,
only this order tells us that <code>c2</code> was created from <code>c1</code>, and that <code>c1</code> was
created from <code>c0</code>. That's good enough for linear development, but is very
insufficient for branching development.</p>

<p>So what are branches and why do we need them? Suppose that we have released <code>c2</code>
in the world, and are working on new features. We have created new commits <code>c3</code>
and <code>c4</code>, but overall the feature is not ready yet.</p>

<p>While we are working on it, we receive complaints about some major problem in
<code>c2</code>. And our customers can't wait for us to finish with our new feature. They
need a fixed <code>c2</code> now!</p>

<p>Luckily, we do have our <code>c2</code> source code. We can "switch" to it, fix the bug,
and release the good version. But where should we put the fix-commit itself?</p>

<p>We might be tempted to temporary save the fixes somewhere, switch back to our
<code>c4</code> version, then apply the fixes and make a <code>c5</code> commit. After all, we do want
this fix to be part of the next version that we are going to release, right?</p>

<p>But what if there's yet another problem with the "fixed" <code>c2</code>? We can't go back
to exactly this code, as we didn't save it anywhere. No, we need a better
solution.</p>

<p>What if every commit "knows" who it's parrent commit is? Let's add another
hidden file, called <code>.repo/commit</code> and for <code>c2</code> it will look like this:</p>

<p><code>
parent: c1
</code></p>

<p>The first commit is a bit special, as it doesn't have a parent. Its
<code>.repo/commit</code> will look like this:</p>

<p><code>
parent:
</code></p>

<p>We can also add more info to this file like:
* author of the commit
* date and time of the commit
* one line summary
* bigger, multi-line description of the changes</p>

<p>Let's suppose we went back and fixed all our commits to have this file. Now we
can switch back to <code>c2</code>, implement the fix and create a new commit (let's say
<code>c5</code>). This commit history will now look like this:</p>

<p><code>
c0 -- c1 -- c2 -- c3 -- c4
             \
              c5
</code></p>

<p>Good! Now we can go back to <code>c5</code> when we need to.</p>

<p>Like when we needed to fix the fix. Let's assume we added one more commit to
<code>c4</code>, we then went back to <code>c5</code> and implemented the new fix on top of it. The
picture now will look like this:</p>

<p><code>
c0 -- c1 -- c2 -- c3 -- c4 -- c6
             \
              c5 -- c7
</code></p>

<h2>Names</h2>

<p>So far so good, but we have just 2 branches and it's getting a bit tedious to
remember the top commit for each of them. Let's name them!</p>

<p>We can do that by creating a file for each branch, and storing in it the top
commit's name.</p>

<p><code>bash
mkdir .repo/branches
echo 'c6' &gt; .repo/branches/main
echo 'c7' &gt; .repo/branches/release-1
</code></p>

<p>(The <code>echo 'c6' &gt; .repo/branches/main</code> command will just create a new file
called <code>.repo/branches/main</code> and make its content be <code>c6</code>. If the file already
exists, it will overwrite it.)</p>

<p>The <code>.repo/branches</code> files are not part of a commit, so let's add them to the
<code>.ignore</code> file:</p>

<p><code>
.repo/commits/*
.repo/branches/*
*.o
main
</code></p>

<p>Let's create another commit in our <code>main</code> branch to see how it works:</p>

<p>```bash</p>

<h1>Set the parent info:</h1>

<p>echo 'parent: c6' > .repo/commit</p>

<h1>Make the commit:</h1>

<p>zip -r -x@.ignore .repo/c8.zip .</p>

<h1>Update the branch pointer:</h1>

<p>echo 'c8' > .repo/branches/main
```</p>

<p>This is tedious and errorprone. I wish somebody will create a program to help
with this ...</p>

<h2>Switching</h2>

<p>Before, I was saying things like "let's switch to <code>c2</code>", or "let's switch to
<code>main</code>", but I never explained how. Well, here is how:</p>

<p>```bash</p>

<h1>Remove all the files and subfolders except for <code>.repo</code>:</h1>

<p>rm -rf * .ignore</p>

<h1>Unzip the relevant commit</h1>

<p>unzip .repo/commits/c2.zip
```</p>

<p>It's not that bad (if we ignore the ugly way we clean up the working folder),
right?</p>

<p>But what if we now go to lunch, and when we come back next day we forget what we
checked out? (Yes, sometimes lunches are that long.)</p>

<p>We can do write some code and then commit:</p>

<p>```bash</p>

<h1>Set the parent info:</h1>

<p>echo 'parent: c8' > .repo/commit</p>

<h1>Make the commit:</h1>

<p>zip -r -x@.ignore .repo/c9.zip .</p>

<h1>Update the branch pointer:</h1>

<p>echo 'c9' > .repo/branches/main
```</p>

<p>Oops! We committed in the wrong branch! The commit was based off of <code>c2</code> but we
forgot that and treated it as if it was based on <code>c8</code> instead.</p>

<p>As Butler Lampson said: "All problems in computer science can be solved by
another level of indirection." So it's time to add another one. We can create a
file <code>.repo/HEAD</code>, which will tell us which branch or commit we're on.</p>

<p>The new "switch" procedure will look like this for going to specific commit:</p>

<p>```bash</p>

<h1>Remove all the files and subfolders except for <code>.repo</code>:</h1>

<p>rm -rf * .ignore</p>

<h1>Unzip the relevant commit</h1>

<p>unzip .repo/commits/c2.zip</p>

<h1>Update HEAD to point to specific commit</h1>

<p>echo 'commits/c2` > .repo/HEAD
```</p>

<p>and for branch:</p>

<p>```bash</p>

<h1>Remove all the files and subfolders except for <code>.repo</code>:</h1>

<p>rm -rf * .ignore</p>

<p>cat .repo/branches/main</p>

<h1>This will tell us that main brach points to c8</h1>

<h1>Unzip the relevant commit</h1>

<p>unzip .repo/commits/c8.zip</p>

<h1>Update HEAD to point to  a branch</h1>

<p>echo 'branches/main` > .repo/HEAD
```</p>

<p>So if we have switched to a branch and make a commit, we move that branch's
pointer to the new commit, but the <code>HEAD</code> still points to the same branch:</p>

<p>```bash
cat .repo/HEAD</p>

<h1>--> branches/main (ok, we're on the main branch)</h1>

<p>cat .branches/main</p>

<h1>--> c8 (the top commit of main is c8)</h1>

<h1>Set the parent info:</h1>

<p>echo 'parent: c8' > .repo/commit</p>

<h1>Make the commit:</h1>

<p>zip -r -x@.ignore .repo/c9.zip .</p>

<h1>Update the branch pointer:</h1>

<p>echo 'c9' > .repo/branches/main
```</p>

<p>But what if we try to commit when we're not on a branch?</p>

<p>```bash
cat .repo/HEAD</p>

<h1>--> commits/c2</h1>

<h1>not a branch. show a cryptic error and hope they know what we're talking about:</h1>

<p>echo "Error: Detached HEAD"
```</p>

<p>(Now you know what "detached HEAD" is in git. It's the case when the <code>HEAD</code> file
pointing to a commit instead of a branch. Git will behave differently than our
system in this case: it will allow you to commit, but the commit will not be
associated with any branch.)</p>

<h2>Merging</h2>

<p>Here is the current situation:</p>

<p><code>
                                     HEAD / main
                                          |
                                          v
c0 -- c1 -- c2 -- c3 -- c4 -- c6 -- c8 -- c9
             \
              c5 -- c7
                    ^
                    |
                release-1
</code></p>

<p>We want to create a new release, but first we want to grab the fixes from
<code>release-1</code> and apply them to our <code>main</code> branch.</p>

<p>One way to do that, is the following:
1. Find the most recent commit, which is parent to both <code>c9</code> and <code>c7</code>. This is
   <code>c2</code>.
2. Find the changes between <code>c2</code> and <code>c7</code> (the <code>release-1</code> branch). We can unzip
   both the commits in 2 temporary folders and then `diff -r -u c2-temp c7-temp</p>

<blockquote>
  <p>changes.diff<code>them.
3. Patch the code in the working folder (</code>c9<code>):</code>patch &lt; changes.diff`
4. Manually fix any conflicts
5. Commit</p>
</blockquote>

<p>Well, there's one more thing. This new commit should have two parents. So let's
make its <code>.repo/commit</code> file read</p>

<p><code>
parent: c9 c7
</code></p>

<p>And the full picture now looks this way:</p>

<p><code>
                                           HEAD / main
                                                |
                                                v
c0 -- c1 -- c2 -- c3 -- c4 -- c6 -- c8 -- c9 -- c10
             \                                 /
              c5 -- c7 ------------------------
                    ^
                    |
                release-1
</code></p>

<p>As you can see, we moved only <code>main</code>, but left <code>release-1</code> unchanged. That is
because we merged the latter into the former.</p>

<h2>Collaboration and remote repositories</h2>

<p><em>TODO</em></p>

<h1>Git</h1>

<p>I will now make what is known as a pro move, and direct you to the excellent
<a href="https://git-scm.com/book/en/v2">Pro Git</a> book! It is free and easy to read, and
now, hopefully, even easier to understand!</p>

<p>It might look like a cop-out and it is. But also, there are already quite good
tutorials, which describe how to use git. My main objective here was to describe
how git works and to some extent to answer the question "why is it like that".</p>
